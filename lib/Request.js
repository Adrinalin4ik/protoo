'use strict';

const EventEmitter = require('events').EventEmitter;

const logger = require('./logger')('Request');
const utils = require('./utils');
const Response = require('./Response');

class Request extends EventEmitter
{
	static factory(req)
	{
		req.__proto__ = new Request();
		// Object.setPrototypeOf(req, new Request());

		req.init();

		return req;
	}

	constructor()
	{
		logger.debug('constructor()');

		super();
		this.setMaxListeners(Infinity);

		/**
		 * JSON fields
		 * - id:     Number (ro), mandatory
		 * - method: String (ro), mandatory
		 * - path:   String (ro), mandatory for incoming requests, removed in outgoing
		 *           or forwarded requests
		 * - data:   Object (rw), optional
		 * - sender: Object (ro), optional for outgoing requests, ignored in incoming
		 *           requests:
	   *   - username: String, mandatory
	   *   - uuid:     String, mandatory
		 */

		/**
		 * Public attributes
		 * - app:   Application (ro), the Protoo app
		 * - peer:   Peer (ro), associated peer sender
		 * - params  Object (ro), generated by the routing
		 * - ended   Boolean (ro), final reply was sent, no more replies allowed
		 */

		/**
		 * Private attributes
		 * - _toString:   String, for toString() method
		 * - _settings:   Object, custom data set with set()
		 * Routing attributes:
		 * - originalPath
		 * - basePath
		 * - next
		 * - route
		 */
	}

	init()
	{
		if (!this.id)
			this.id = utils.randomNumber();

		this.data = this.data || {};

		this.ended = false;  // TODO

		this._settings = new Map();
	}

	toString()
	{
		return this._toString || (this._toString = `[method:${this.method}, id:${this.id}', path:${this.originalPath || this.path}]`);
	}

	json()
	{
		let json =
		{
			method : this.method,
			id     : this.id,
			data   : this.data
		};

		if (this.sender)
			json.sender = this.sender;

		return JSON.stringify(json);
	}

	set(key, value)
	{
		this._settings.set(key, value);
	}

	get(key)
	{
		return this._settings.get(key);
	}

	reply(status, reason, data)
	{
		let res;

		if (status instanceof Response)
		{
			res = status;
		}
		// Create a Response instance
		else
		{
			res = Response.factory(
				{
					id     : this.id,
					status : status,
					reason : reason || '',
					data   : data
				});
		}

		if (res.status >= 200)
		{
			if (this.ended)
				throw new Error('already replied with a final response');

			this.ended = true;
		}

		logger.debug('reply() | %s', res);

		// Emit "outgoingResponse"
		this.emit('outgoingResponse', res);

		// Send it
		this.peer.send(res);
	}

	createResponse(status, reason, data)
	{
		// Return a Response instance
		return Response.factory(
			{
				id     : this.id,
				status : status,
				reason : reason || '',
				data   : data
			});
	}
}

module.exports = Request;
